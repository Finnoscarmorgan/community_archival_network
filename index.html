<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Archival Networks: communities (>120 members), sized by betweenness</title>
<style>
  html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  #app { display: grid; grid-template-rows: auto 1fr; height: 100%; }
  header { padding: 10px 14px; border-bottom: 1px solid #ddd; display: grid; gap: 8px; grid-template-columns: 1fr auto auto; align-items: center; }
  header h1 { margin: 0; font-size: 18px; font-weight: 600; }
  .controls { display: inline-flex; gap: 8px; align-items: center; flex-wrap: wrap; }
  .controls input[type="text"] { padding: 6px 8px; border: 1px solid #ccc; border-radius: 4px; width: 280px; }
  .controls label, .controls select { font-size: 14px; }
  .legend { display: inline-flex; align-items: center; gap: 14px; font-size: 13px; flex-wrap: wrap; }
  .legend .item { display: inline-flex; align-items: center; gap: 6px; }
  .legend .swatch { width: 12px; height: 12px; border-radius: 50%; border: 1px solid #999; }
  #chart { position: relative; }
  svg { width: 100%; height: 100%; display: block; background: #fafafa; }
  .node { cursor: pointer; }
  .node circle { stroke: #fff; stroke-width: 1px; }
  .link { stroke: #bbb; stroke-opacity: 0.6; }
  .tooltip {
    position: absolute; pointer-events: none; background: rgba(255,255,255,0.98);
    border: 1px solid #ccc; border-radius: 4px; padding: 8px 10px; font-size: 12px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.08);
  }
  .panel { position: absolute; right: 12px; top: 12px; background: rgba(255,255,255,0.98);
    border: 1px solid #ddd; padding: 10px; border-radius: 6px; font-size: 13px; max-width: 360px;
  }
  .panel h3 { margin: 0 0 6px 0; font-size: 14px; }
  #exit-focus {
    position: absolute; left: 12px; top: 12px; padding: 6px 10px; font-size: 13px;
    border: 1px solid #ccc; border-radius: 4px; background: white; cursor: pointer; display: none;
  }
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>Archival Networks: communities (>120 members), sized by betweenness</h1>

    <div class="controls">
      <input id="search" type="text" placeholder="Search nameâ€¦" />
      <label><input id="toggle-mentioned" type="checkbox" checked /> Show mentioned-only</label>
      <label><input id="toggle-holders" type="checkbox" checked /> Show archive holders</label>
      <label><input id="toggle-dir" type="checkbox" /> Show direction</label>
      <label>Community:
        <select id="community-filter"><option value="">All communities</option></select>
      </label>
    </div>

    <div class="legend" id="legend">
      <div class="item"><span class="swatch" style="background:linear-gradient(90deg,#eee,#000)"></span> Size = betweenness</div>
    </div>
  </header>

  <div id="chart">
    <button id="exit-focus" title="Exit focus view">Exit focus</button>
    <svg></svg>
    <div class="panel" id="info">
      <h3>About this view</h3>
      <p>
        This visualisation shows only communities with more than 120 members. Node colour indicates Louvain community.
        Node size is proportional to betweenness centrality. Use search to locate a person. Click a node to enter focus
        mode and see only that node and its immediate connections. Click the background or press Esc to exit focus.
      </p>
      <!--<p class="muted">Files: Network_A_nodes_with_community.csv, Network_A_links.csv</p>-->
    </div>
    <div class="tooltip" style="display:none;" id="tooltip"></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<script>
(async function() {
  const MIN_COMMUNITY_SIZE = 120;

  const files = {
    nodes: 'Network_A_nodes_with_community.csv',
    links: 'Network_A_links.csv'
  };

  // Load data
  const [nodesRaw, linksRaw] = await Promise.all([
    d3.csv(files.nodes, d3.autoType),
    d3.csv(files.links, d3.autoType)
  ]);

  // Normalise nodes; use name as unique id
  let nodes = nodesRaw.map(d => ({
    id: String(d.name || d.id || ''),
    name: String(d.name || d.id || ''),
    type: d.type || 'mentioned_only',
    betweenness: +d.betweenness || 0,
    community: d.community != null && d.community !== '' ? String(d.community) : 'unassigned'
  })).filter(d => d.id);

  // Community counts and filtering to > MIN_COMMUNITY_SIZE
  const commCountsAll = d3.rollup(nodes, v => v.length, d => d.community);
  const retainedCommunities = new Set([...commCountsAll].filter(([c, n]) => n > MIN_COMMUNITY_SIZE).map(([c]) => c));
  nodes = nodes.filter(d => retainedCommunities.has(d.community));

  // Build map for fast lookups
  const nodeByName = new Map(nodes.map(d => [d.name, d]));

  // Filter links to the retained node set
  const links = linksRaw
    .map(d => ({ source: String(d.source), target: String(d.target), weight: +d.weight || 1 }))
    .filter(d => nodeByName.has(d.source) && nodeByName.has(d.target));

  // If no communities pass the threshold, bail gracefully
  if (nodes.length === 0) {
    document.querySelector('#chart').insertAdjacentHTML('beforeend',
      '<div style="position:absolute;left:12px;bottom:12px;font-size:14px;color:#444;">No communities exceed the selected size threshold.</div>');
    return;
  }

  // Scales
  const betExtent = d3.extent(nodes, d => d.betweenness);
  const size = d3.scaleSqrt()
    .domain([Math.max(0, betExtent[0] || 0), Math.max(1e-6, betExtent[1] || 1e-3)])
    .range([3, 18]);

  // Community palette
  const communities = Array.from(retainedCommunities).sort((a, b) => {
    const an = +a, bn = +b;
    if (!Number.isNaN(an) && !Number.isNaN(bn)) return an - bn;
    return String(a).localeCompare(String(b));
  });

  const palette = d3.schemeTableau10.concat(d3.schemeSet3 || []);
  const colourOrdinal = d3.scaleOrdinal().domain(communities).range(palette.slice(0, Math.max(communities.length, 1)));
  const colour = d => {
    if (communities.length <= palette.length) return colourOrdinal(d.community);
    const idx = communities.indexOf(d.community);
    const t = idx / Math.max(1, communities.length - 1);
    return d3.interpolateRainbow(t);
  };

  // Build legend for retained communities
  const commCounts = d3.rollup(nodes, v => v.length, d => d.community);
  const topLegend = Array.from(commCounts, ([k, v]) => ({ community: k, count: v }))
                         .sort((a, b) => d3.descending(a.count, b.count))
                         .slice(0, 12);
  const legend = d3.select('#legend');
  legend.selectAll('.item.comm').data(topLegend).join('div')
    .attr('class', 'item comm')
    .html(d => `<span class="swatch" style="background:${colour({community: d.community})}"></span> C${d.community} (${d.count})`);

  // Populate community dropdown
  const selComm = document.getElementById('community-filter');
  for (const c of communities) {
    const opt = document.createElement('option');
    opt.value = c;
    opt.textContent = `Community C${c} (${commCounts.get(c)})`;
    selComm.appendChild(opt);
  }

  // SVG and layers
  const svg = d3.select('svg').attr('width', 900).attr('height', 600);
  const width = svg.node().clientWidth, height = svg.node().clientHeight;
  const g = svg.append('g');
  const linkLayer = g.append('g').attr('stroke-linecap', 'round');
  const nodeLayer = g.append('g');

  // Arrowhead marker for direction toggle
  const defs = svg.append('defs');
  defs.append('marker')
    .attr('id', 'arrow')
    .attr('viewBox', '0 -3 6 6')
    .attr('refX', 18)
    .attr('refY', 0)
    .attr('markerWidth', 6)
    .attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path').attr('d', 'M0,-3L6,0L0,3Z').attr('fill', '#bbb');

  // Simulation
  const simulation = d3.forceSimulation(nodes)
    .force('link', d3.forceLink(links).id(d => d.id).distance(40).strength(0.05))
    .force('charge', d3.forceManyBody().strength(-30))
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force('collide', d3.forceCollide().radius(d => size(d.betweenness) + 2));

  // Links
  const link = linkLayer.selectAll('line')
    .data(links)
    .join('line')
    .attr('class', 'link')
    .attr('stroke-width', 1)
    .attr('stroke', '#bbb');

  // Direction toggle
  const chkDir = document.getElementById('toggle-dir');
  chkDir.addEventListener('change', () => {
    link.attr('marker-end', chkDir.checked ? 'url(#arrow)' : null);
  });

  // Nodes
  const node = nodeLayer.selectAll('g.node')
    .data(nodes)
    .join('g')
    .attr('class', 'node')
    .call(drag(simulation));

  node.append('circle')
    .attr('r', d => size(d.betweenness))
    .attr('fill', d => colour(d))
    .attr('opacity', 0.85);

  node.append('title').text(d => `${d.name}
Type: ${d.type}
Community: C${d.community}
Betweenness: ${d.betweenness.toFixed(6)}`);

  // Tooltip
  const tooltip = d3.select('#tooltip');
  node.on('mousemove', function(event, d) {
    tooltip.style('display', 'block')
      .style('left', (event.clientX + 12) + 'px')
      .style('top', (event.clientY + 12) + 'px')
      .html(`<strong>${d.name}</strong><br/>
             Type: ${d.type.replace('_', ' ')}<br/>
             Community: C${d.community}<br/>
             Betweenness: ${d.betweenness.toFixed(6)}`);
  }).on('mouseleave', () => tooltip.style('display', 'none'));

  // Zoom and pan
  const zoom = d3.zoom().scaleExtent([0.2, 6]).on('zoom', (event) => g.attr('transform', event.transform));
  svg.call(zoom);

  // Focus mode and search
  let focusedId = null;
  const exitBtn = document.getElementById('exit-focus');

  function neighbourhood(id) {
    const keep = new Set([id]);
    links.forEach(l => {
      const s = typeof l.source === 'string' ? l.source : l.source.id;
      const t = typeof l.target === 'string' ? l.target : l.target.id;
      if (s === id) keep.add(t);
      if (t === id) keep.add(s);
    });
    return keep;
  }

  function focusNode(id) {
    focusedId = id;
    exitBtn.style.display = 'inline-block';
    const neigh = neighbourhood(id);

    node.style('display', d => neigh.has(d.id) ? null : 'none');
    link.style('display', l => {
      const s = typeof l.source === 'string' ? l.source : l.source.id;
      const t = typeof l.target === 'string' ? l.target : l.target.id;
      return (s === id || t === id) ? null : 'none';
    });
  }

  function clearFocus() {
    if (!focusedId) return;
    focusedId = null;
    exitBtn.style.display = 'none';
    node.style('display', null);
    link.style('display', null);
    applyFilters(); // reapply user filters after exiting focus
  }

  node.on('click', function(event, d) {
    event.stopPropagation();
    if (focusedId === d.id) { clearFocus(); return; }
    focusNode(d.id);
    svg.transition().duration(600).call(zoom.translateTo, d.x, d.y);
  });

  svg.on('click', clearFocus);
  window.addEventListener('keydown', e => { if (e.key === 'Escape') clearFocus(); });
  exitBtn.addEventListener('click', clearFocus);

  // Search enters focus mode on the first match
  const searchInput = document.getElementById('search');
  searchInput.addEventListener('input', () => {
    const q = searchInput.value.trim().toLowerCase();
    if (!q) { clearFocus(); return; }
    const match = nodes.find(n => n.name && n.name.toLowerCase().includes(q));
    if (match) {
      focusNode(match.id);
      if (typeof match.x === 'number' && typeof match.y === 'number') {
        svg.transition().duration(600).call(zoom.translateTo, match.x, match.y);
      }
    }
  });

  // Filters: community selector and node type toggles
  const chkMentioned = document.getElementById('toggle-mentioned');
  const chkHolders   = document.getElementById('toggle-holders');

  selComm.addEventListener('change', () => { if (!focusedId) applyFilters(); });
  chkMentioned.addEventListener('change', () => { if (!focusedId) applyFilters(); });
  chkHolders.addEventListener('change', () => { if (!focusedId) applyFilters(); });

  function applyFilters() {
    const chosen = selComm.value; // '' means all
    // Decide node visibility
    node.each(function(d) {
      const hideByType =
        (d.type === 'mentioned_only' && !chkMentioned.checked) ||
        (d.type === 'archive_holder' && !chkHolders.checked);
      const hideByComm = chosen && String(d.community) !== String(chosen);
      const visible = !(hideByType || hideByComm);
      this.style.display = visible ? null : 'none';
    });

    // Visible nodes set
    const visibleIds = new Set();
    node.each(function(d) { if (this.style.display !== 'none') visibleIds.add(d.id); });

    // Hide links if an endpoint is hidden
    link.style('display', function(l) {
      const s = typeof l.source === 'string' ? l.source : l.source.id;
      const t = typeof l.target === 'string' ? l.target : l.target.id;
      return (visibleIds.has(s) && visibleIds.has(t)) ? null : 'none';
    });
  }

  // Run once so initial state respects controls
  applyFilters();

  // Simulation tick
  simulation.on('tick', () => {
    link.attr('x1', d => (typeof d.source === 'string' ? nodeByName.get(d.source).x : d.source.x))
        .attr('y1', d => (typeof d.source === 'string' ? nodeByName.get(d.source).y : d.source.y))
        .attr('x2', d => (typeof d.target === 'string' ? nodeByName.get(d.target).x : d.target.x))
        .attr('y2', d => (typeof d.target === 'string' ? nodeByName.get(d.target).y : d.target.y));
    node.attr('transform', d => `translate(${d.x},${d.y})`);
  });

  // Drag behaviour
  function drag(sim) {
    function dragstarted(event, d) { if (!event.active) sim.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
    function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
    function dragended(event, d) { if (!event.active) sim.alphaTarget(0); d.fx = null; d.fy = null; }
    return d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended);
  }
})();
</script>
</body>
</html>
